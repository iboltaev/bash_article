# Article about using Bash in SQL-style for text processing

#bash, #tutorial, #linux, #sql

Приветствую! Данная небольшая статья призвана осветить некоторые аспекты применения Bash для анализа файлов в SQL-стиле. Думаю,
будет интересна для новичков, возмжно, опытные пользователи также найдут для себя что-нибудь новое.

Структура задачи:
- projects/
  - project1/
    - conf/
      - [run configurations]*.conf  -- конфигурации построения отчетов по таблицам
    - reports/
      - [run configurations]/   --  папки с конфигурациями
        - report1.json          --  сами отчеты, содержат статистику по таблицам Apache Hive    
        - report2.json
  - project2/
  
Надо: найти просроченные отчеты.

Итак, расчехляем Bash, открываем отдельный терминал для man-ов и приступаем)

Всех, кому интересно - прошу под кат.

----------------------------------------------------------------------------------------------------------------------------------

  Итак, мы имеем: внутреннюю систему построения отчетов в виде папки с проектами. В каждом проекте в папке conf лежат конфигурации
построения отчетов, содержащие в себе имена Hive-овых баз данных в полях "*schema*", по таблицам которых строятся отчеты. В папке 
reports - сами отчеты, разложенные в папки с именами конфигураций. Каждый отчет - это json, содержащий статистику по Hive-овым таблицам 
в массиве объектов "table", а также дату создания в поле "created_date". Возьмем ее вместо даты создания файла, раз уж есть. Нам надо
найти такие отчеты, в которых содержатся таблицы, которые были изменены после создания отчета.

  Почему в SQL-стиле? Bash предоставляет большие возможности работы с текстом, разделенным на колонки (обычно пробелами), напоминающие обработку таблиц в SQL. 
  Наш инструментарий:
  - cat, find, grep и прочее - в представлении не нуждаются)
  - sed - используем для тупой автозамены
  - awk - позволяет отображать/переставлять/сливать колонки, фильтровать строки по содержимому колонок
  - sort, uniq - наверное, любимые инструменты разгребателей логов) Первый - сортирует, второй - удаляет/подсчитывает дубликаты.
    Используются для всяких top N, типа sort -k field_num | uniq -c | sort -n -r -k 1 | head -n N
  - xargs - обрабатывает поток строк одной командой. Может развернуть строки в argument-list для заданной команды, а может для каждой       строки эту команду выполнить.
  - join - натуральный SQL-евский INNER JOIN. Сливает 2 сортированных файла по значению одного одинакового поля в один, сначала идет
    общее поле, затем оставшиеся поля первого файла, потом - второго.

  Приступим. Для начала - просто нагрепаем используемые таблицы. Проекты содержат в себе большое количество разного мусора, так что
 запуск в лоб
```  
  grep -r "\"table\":" projects
```  
отрабатывает сильно долго. Поэтому делаем так:
```
  find projects -maxdepth 1 | sed 's/$/\/reports\//g' | xargs -n1 -I dr grep -r "\"table\":" dr | ...
```  
Берем содержимое первого уровня папки projects, добавляем в конец /reports/, и только теперь в каждой такой папке запускаем grep -r.
Он отдает нам данные в таком виде:
```  
projects/project1/reports/run1/report1.json:            "table": "table1",
projects/project1/reports/run2/report2.json:            "table": "table2",
projects/project2/reports/run3/report3.json:            "table": "table3",
...
```
```
  ... |  awk '{print $1 " " $3}' | sed 's/[\r\n",:]//g' | grep "\s[A-Za-z0-9]" | sort -k 1b,1 | uniq > report_tables
```

Печатаем первую (файл отчета) и третью (имя таблицы) колонки, чистим мусор sed-ом, затем grep-ом, пересортировываем и сохраняем в нашу
первую таблицу - report_tables.

Затем таким же способом строим таблицу report_dates, только грепаем created_date и выводим чуть больше колонок (дату и время):
```
find projects -maxdepth 1 | sed 's/$/\/reports\//g' | xargs -n1 -I dr grep -r "\"created_date\":" dr | ...
... | awk '{print $1 " " $3"T"$4}' | sed 's/[\r\n",:]//g' | sort -k 1b,1 | uniq > report_dates
```

Теперь джойним их, и получаем таблицу с файлами отчетов, таблицами и датами создания этого отчета:
```
join report_tables report_dates > report_table_date
```
```
projects/project1/reports/run1/report1.json table1 2017-08-07T070918.024907
projects/project1/reports/run1/report1.json table2 2017-08-07T070918.024907
projects/project1/reports/run1/report1.json table3 2017-08-07T070918.024907
...
```
Первая часть готова.
